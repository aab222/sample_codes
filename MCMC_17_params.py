''' MCMC code to vary 17 parameters simultaneously in the rotational evolution
    models. These parameters all govern rotational evolution.

    Parameters are:
                    14 knot points in turnover time vs effective temperature
                    function (i.e. this function is represented as a series of
                    x and y coordinates, where x is T_eff and y tau_c. Values
                    between knot points are linearly interpolated in the models.
                    The y coordinates are randomly varied for an optimal fit
                    to observed data using MCMC.)

                    3 stellar wind torque parameters ks, ps and p, which define
                    a broken power law and govern the rotational evolution.

    Each set of parameters requires the generation of model probability
    densities, and a tau squared fit to observed cluster data.

    To run, this code needs:

    control/constants script to control the:
        1) rotational evolution code
        2) gridding of model probability densities
        3) tau squared statistical technique code
    rotational evolution code to:
        1) evolve model stars and rotation rates in time to desired age
        2) generate resulting rotation period-mass distributions at desired age
        3) calclulate model probability densities from step 2),
           either as a grid or as a continuous distribution
    cluster data code to:
        1) supply datasets for various clusters, to which the rotational
           evolution model will be fit
    tau squared code to:
        1) take model probability densities and cluster datasets and provide
           a goodness of fit value'''

# =============================import codes=====================================

# import multiprocessing packages
import multiprocessing
from multiprocessing import Pool
from multiprocessing import cpu_count
import multiprocessing as mp

# import python MCMC package(s)
import emcee
import h5py  # to save emcee progress

# import other useful python packages
import numpy as np
import time
import sys
import math
import matplotlib.pyplot as plt

# import my own codes
sys.path.insert(0, '../data')
import myconstants as const                     # constants code
import calc_sb_evol as spinEvol                 # rotational evolution code
import clusterData as cluster                   # cluster datasets
import calculatetauSquared as tau2              # tau-squared statistical code

'''=================Varying tau_c(Teff) AND torque==================='''
# once MCMC object has been setup, parameter search can be initialised. To do
# this, the following functions will be needed.For each random set of parameters
# generated by MCMC, the following functions are needed:
#   model_change_tauc_and_torque: to generate model probability densities for
#       each set of random parameters.
#   lnprior_change_tauc_and_torque: to check that the parameters are reasonable.
#       accept the step if so, return ln(probability) = -infinity if not.
#    lnpost_change_Tauc_and_torque: provided step is accepted, go on to do a
#       tau squared fit to assess how well the resulting model distribution fits
#       the actual data.

def generate_prior(ndim,space='log'):
    '''
    generates the prior as an array of max and min values for each of the
    ndim dimensions explored.

    in:
        ndim: number of dimensions to be varied in MCMC (integer)
        log:  decides if tau_c is in log or linear space (ascii 'y' or 'n')
    out:
        prior: shape is (ndim,2). There is
                min limit (prior[x][0])
                max limit (prior[x][1])
               for each of the x parameters. Last 3 entries (prior[-3:][y])
               correspond to torque law. All others correspond to tau_c.
    '''

    '''prior for convective turnover time:'''
    # setting up empty array and reshaping
    prior = np.zeros((ndim,2))
    prior = prior.T

    # generating tau_c knot points in log(tauc/tausun):
    prior[0][:] = np.log(1e-8)      # min for all knot points
    prior[1][0:6] = np.log(20)      # max for <= 0.6 MsunÃ¥
    prior[1][6:-1] = np.log(12)     # max for >  0.6 Msun

    # reshaping array
    prior = prior.T

    # do we need to convert to linear tau_c(tau_sun)?
    if space == 'linear':
        # convert to linear space
        prior = prior.T
        prior[0][0:-3] = np.exp(prior[0][0:-3])
        prior[1][0:-3] = np.exp(prior[1][0:-3])
        prior = prior.T

    '''prior for torque law:'''
    # prior for ps
    prior[14][0] = -0.25 # min ps
    prior[14][1] = 0.6   # max ps
    # prior for ks
    prior[15][0] = 0.0   # min ks
    prior[15][1] = 800   # max ks
    # prior for p
    prior[16][0] = 1.0   # min p
    prior[16][1] = 2.8   # max p

    return prior
prior = generate_prior(ndim=17,space='linear')

def check_space(params,space):
    # returns parameters in linear space if they have been passed through
    # in log space.
    if  space == 'log':
        # convert to linear space
        params = np.exp(params)   # units of tausun
        return params

    elif space == 'linear':
        return params

    else:
        sys.exit("please provide keyword\
                 of \'log\' or \'linear\' for space parameter")

def model_change_tauc_and_torque(age,X,tcX,tcY,
                                endknot,initialConditions='N/A',
                                torque_law='Matt2020'):

    ''' generates probability densities for rotational evolution model
        with desired parameters. This calles the spinEvol code.
    in:
        age: age to which rotation rates are evolved (Myr)
        X:  torque parameters [ps,ks,p,beta], where beta is optional
        tcX: effective temperatures of knot points
        tcY: turnover times of knot points. i.e. y coordinates of
             convective Turnover Time [y1,..,y14]
        endknot: if not default, turnover time is defined by mixture
             of knot points and Cranmer and Saar/ Amard functions
        initialConditions: rotation model initial conditions, either
            a uniform tophat, or KDEs defined by upper Sco (e.g.
            "Tophat","UpperSco")
        torque_law: choose the torque law used to evolve rotation rates
            (e.g. "Matt2020", "Matt2015")
    out:
        spinEvol.stellarDictionary: dictionary containing stellar
            structure information, rotational evolution information,
            and probability density information for stars from
            0.1 to 1.3 Msun, from birth to the end of the main sequence'''

    spinEvol.generate_cluster_prob_density(
             age,X=X,tcX=tcX,tcY=tcY,
             endknot=endknot,torque_law=torque_law)

    return spinEvol.stellarDictionary

def lnprior_change_tauc_and_torque(params,space):
    '''
    checks that the model parameters are within the accepted range
    in:
        params:
    out:
        ln(prior): either 0.0 for an accepted set of parameters,
                   or -infinity for unaccepted parameters
        statement: string of characters used to trace back which
                   parameters caused the MCMC step not to be accepted '''

    # check the parameters fall with in the max and min lims of prior

    for i in range(len(params)):
        if (params[i] < prior[i][0]) or (params[i] > prior[i][1]):
            statement = 'parameter %s is out of bounds, %s' %(i+1,params[i])
            return -np.inf,statement
    return 0.0, 'accepted'

def lnpost_change_Tauc_and_torque(params,tcX,endknot,age,cluster,
                                  initialConditions,torque_law,space):

    # calculates and returns the posterior likelihood of a set of parameters
    # and is the function emcee uses.

    # check the space the parameters are in and convert to linear if needed
    params = check_space(params,space)
    # careful define which parameters belong to which prior

    tcY = params[0:-3]
    X   = params[-3:]
    tcYRounded = [round(num,4) for num in tcY]
    XRounded = [round(num,2) for num in X]

    # set up of terminal info
    tMCMC_i = time.time()

    # calculate ln(prior)
    lnprior = lnprior_change_tauc_and_torque(params,space)
    lnprior_statement = lnprior[1]
    lnprior = lnprior[0]

    # if prior is -infinity:
    if not np.isfinite(lnprior):
        timeCalc = abs(time.time()-tMCMC_i)
        print('NOT ACCEPTED: time:%.2fs, lnprior:%s %s\
              \ntcY [TauSun]:%s, X:%s' \
              %(timeCalc,lnprior,lnprior_statement,tcYRounded,XRounded))
        return -np.inf, -np.inf

    # calculate ln(likelihood)
    model = model_change_tauc_and_torque(age,X,tcX,tcY,endknot,\
                                        initialConditions,torque_law)
    lnllhd = -0.5*tau2.calc_tau2_spline(model,modelProb=0.7,f3=[],\
                    params=[tcYRounded,XRounded],cluster=cluster)

    # if log(likelihood) is infinity:
    if not np.isfinite(lnllhd):
        timeCalc = abs(time.time()-tMCMC_i)
        print('NOT ACCEPTED: time:%.2f s, tcY: %s, X:%s, lnprior:%s, ln(L):%s'\
                %(timeCalc,tcYRounded,XRounded,lnprior,lnllhd))
        return lnprior, lnllhd

    # if neither ln(likelihood) nor ln(prior) is -infinity:
    timeCalc = abs(tMCMC_i-time.time())
    print('\nACCEPTED, time:%.2f s, lnprior:%s, tau2:%.2f,\
                \ntcY:%s, X:%s'\
                %(timeCalc,lnprior,lnllhd*-2,tcYRounded,XRounded))

    return lnprior + lnllhd, lnprior


'''============================Setup of problem=============================='''
# set up the desired MCMC scenario by defining an object containing all
# information about MCMC run. Includes e.g. number of walkers, number of steps,
# initial walker positions, number of threads, save filepaths, etc. Once this is
# setup, MCMC can be run using the object's explore_17_params function. The
# results can then be plotted in another routine.
class MCMCObj:

    # Initializer / Instance Attributes
    def __init__(self,space):

        # define where to save results?
        self.root = '/data/aab222/MCMC/TurnoverTime/deterministicEvolution'\
                    '14knots3torque/uniformIC/200w_1000s'
        self.fileName = self.root+'/linsearch.txt'


        # computing setup for MCMC
        self.nwalkers = 36#200
        self.nsteps =  1#1000
        self.nthreads = 1#8#0


        # define starting guess for torque law parameters
        self.X = [-0.1,100.,2.0]
        self.stdv_torq = [0.2,50.,0.45]

        # define starting guess for turnovertime vs Teff knot points
        tcX,tcY = spinEvol.define_knots_entireSequence()
        self.tcY = tcY              # linear tau in units of tau_sun
        self.tcX = tcX              # Teff in units of K
        self.Nknots = len(tcX)

        # if you want tau_c to revert to the predefined function of either
        # Cranmer and Saar or Amard above some Teff, set endknot to this Teff.
        self.endknot = []

        # MCMC setup
        self.ndim = self.Nknots + len(self.X)

        # rotational evolution model setup
        self.age = 665.            # Myr
        self.initialConditions  = 'Matt2020'
        self.torque_law         = 'Matt2020'
        self.cluster            = 'Praesepe'

        # setup priors
        self.space = 'log'

        # initiaising walkers
        self.set_pos_initial()
        # check no walkers are outwith priors & reinitialise if so
        self.check_prior()
        # plot up the walker distribution
        self.plot_walkers()

    def set_pos_initial(self):
        # will want different distributions to choose from here in the future
        self.uniform_tauc_gaussian_torque()

    def uniform_tauc_gaussian_torque(self):
        # pos is in linear tauc (units of tau_sun)

        # merge parameter arrays into one
        self.param_tot = np.concatenate((prior.T[0][0:-3], self.X))

        # want lower temperatures to have larger stdv than higher temperatures:
        stdv_tauc_lowT = np.full((1,6),prior.T[1][0:-3-8])[0]
        stdv_tauc_hiT  = np.full((1,8),prior.T[1][6:-3])[0]
        self.stdv_tauc = np.concatenate((stdv_tauc_lowT,stdv_tauc_hiT))#lin tauc

        # generate random initial tauc positions in uniform linear space
        tauc_pos = np.array([prior.T[0][0:-3] + \
                                            self.stdv_tauc*np.random.uniform(
                                            low=0.,high=1,size=self.ndim-3)
                                            for i in range(self.nwalkers)])

        # generate random initial torque positions in linear space centred
        # around gaussian
        X_pos = np.array(\
                [self.X + self.stdv_torq*np.random.normal(size=len(self.X))
                                            for i in range(self.nwalkers)])

        # merge pos arrays into one
        self.pos = np.array(\
        [np.concatenate((tauc_pos[i],X_pos[i])) for i in range(self.nwalkers)])

    def explore_17_params(self):

        # start MCMC process
        tMCMC = time.time()

        # execute MCMC with defined number of threads
        with Pool(self.nthreads) as pool:

            self.sampler = emcee.EnsembleSampler(self.nwalkers,self.ndim,\
                             lnpost_change_Tauc_and_torque,\
                             args=(self.tcX,self.endknot,self.age,\
                             'Praesepe',self.initialConditions,\
                             self.torque_law,self.space),pool=pool)

            self.sampler.run_mcmc(self.pos, self.nsteps)

        log_prior_samps = self.sampler.get_blobs()
        flat_log_prior_samps = self.sampler.get_blobs(flat=True)

        self.NburnIn = int(self.nsteps/3)
        self.samples=self.sampler.chain[:, self.NburnIn:, :].\
                     reshape((-1, self.ndim))

        # save walkers
        self.timeTaken = abs(time.time()-tMCMC)
        self.save_results()

    def save_results(self):

        # ======= save walkers=========
        f = open(self.fileName,'w')
        f.write('# Time taken to run MCMC with %s threads: %.2f s,  %.2f m,'\
                ' %.2f h \n' \
                %(self.nthreads,self.timeTaken, self.timeTaken/60.,\
                  self.timeTaken/3600.))
        # getting rid of the 'burn in' phase, removing elements
        f.write('# Number of parameters: %s \n' %self.ndim)
        f.write('# Number of walkers: %s \n' %self.nwalkers)
        f.write('# Number of steps (total): %s \n' %self.nsteps)
        f.write('# Number of burnin steps: %s \n' %self.NburnIn)
        f.write('# Mean acceptance fraction (0.25-0.5): {0:.3f}\n'.format(\
                                    np.mean(self.sampler.acceptance_fraction)))
        f.write('# Mean parameters (W_y is log(tau_c/tau_sun))according'\
                'to NburnIn are:')

        for i in range(len(self.samples.mean(axis=0))):
            f.write(' %s \t' %self.samples.mean(axis=0)[i])
        f.write('\n')
        f.write('# ========================================================\n')
        f.write('# ')

        # write header first ...
        for j in range(self.nwalkers):
            for k in range(len(self.sampler.chain[0][0])):
                f.write('W_y%s_%s\t\t' %(k+1,j+1))
            f.write('Tau2_%s\t\t' %(j+1))

        # ... and then write walkers
        #cycling through number of steps for each walker
        for i in range(len(self.sampler.chain[0])):
            f.write('\n')
            for j in range(self.nwalkers):
                for k in range(len(self.sampler.chain[0][0])):
                    f.write('%s\t' %(self.sampler.chain[j][i][k]))
                f.write('%s\t' %self.sampler.get_log_prob()[i][j])
        f.close()

        # calculating statistics and printing to terminal
        print('===============================================')
        print('=== Time taken to run MCMC: %.2f s, %.2f m, %.2f h' \
                            %(self.timeTaken,self.timeTaken/60,\
                            self.timeTaken/3600))
        print("=== Mean acceptance fraction (0.25-0.5): {0:.3f}".format(\
                            np.mean(self.sampler.acceptance_fraction)))
        # print("=== Longest autocorrelation length: %s" %sampler.acor)
        # print("=== Autocorrelation time estimate: %s" \
        #                   %sampler.get_autocorr_time())
        print('=== Mean parameters are:',self.samples.mean(axis=0))
        print('===============================================')

# ============================set code running==================================
# setup the MCMC problem
MCMC = MCMCObj(space='linear')
# run the MCMC and save output - can change default behaviour if desired
MCMC.explore_17_params()
